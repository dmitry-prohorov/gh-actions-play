# This is a basic workflow to help you get started with Actions

name: DevelopCI

# Controls when the action will run. Triggers the workflow on push
# events but only for the develop branch
on:
  push:
    branches: "master"
    paths:
      - "force-app/**"

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "deploy"
  deploy:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2-beta
        with:
          node-version: "13.x"
      # - name: Cache node modules
      #   id: cache-node-modules
      #   uses: actions/cache@v2
      #   env:
      #     cache-name: cache-node-modules
      #   with:
      #     path: "**/node_modules"
      #     key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
      #     restore-keys: |
      #       ${{ runner.os }}-build-${{ env.cache-name }}-
      #       ${{ runner.os }}-build-
      #       ${{ runner.os }}-

      - name: Get changed files
        id: file_changes
        uses: dmitry-prohorov/file-changes-action@master

      - name: Check files
        uses: actions/github-script@v2
        env:
          files: ${{ steps.file_changes.outputs.files }}
          files_added: ${{ steps.file_changes.outputs.files_added }}
          files_modified: ${{ steps.file_changes.outputs.files_modified }}
          files_removed: ${{ steps.file_changes.outputs.files_removed }}
          files_renamed: ${{ steps.file_changes.outputs.files_renamed }}
          files_previous: ${{ steps.file_changes.outputs.files_previous }}
        with:
          script: |
            console.log('files', process.env.files);
            console.log('files_added', process.env.files_added);
            console.log('files_modified', process.env.files_modified);
            console.log('files_removed', process.env.files_removed);
            console.log('files_renamed', process.env.files_renamed);
            console.log('files_previous', process.env.files_previous);
            const path = require('path');
            const added = JSON.parse(process.env.files_added);
            const modified = JSON.parse(process.env.files_modified);
            const renamed = JSON.parse(process.env.files_renamed);
            const removed = JSON.parse(process.env.files_removed);
            const previous = JSON.parse(process.env.files_previous);
            console.log(Array.isArray(added));

            const deployMetadata = new Set([...added, ...modified, ...renamed].map((file) => {
              if (file.includes('/aura/') || file.includes('/lwc/') || file.includes('/staticresources/')) {
                const filePathParts = path.dirname(file).split(path.sep);
                console.log(filePathParts);
                const metadataFolderIndex = (filePathParts.includes('aura') && filePathParts.indexOf('aura'))
                  || (filePathParts.includes('lwc') && filePathParts.indexOf('lwc'))
                  || (filePathParts.includes('staticresources') && filePathParts.indexOf('staticresources'));
                console.log(metadataFolderIndex);
                const metadataPath = filePathParts.slice(0, metadataFolderIndex + 2).join(path.sep);
                console.log(metadataPath);
                return metadataPath;
              }

              return file;
            }));

            const deleteMetadata = [...removed, ...previous].map((file) => {
              if (path.extname(file) === '.xml' && (file.includes('/aura/') || file.includes('/lwc/') || file.includes('/staticresources/'))) {
                const filePathParts = path.dirname(file).split(path.sep);
                const metadataFolderIndex = (filePathParts.includes('aura') && filePathParts.indexOf('aura'))
                  || (filePathParts.includes('lwc') && filePathParts.indexOf('lwc'))
                  || (filePathParts.includes('staticresources') && filePathParts.indexOf('staticresources'));
                const metadataPath = filePathParts.slice(0, metadataFolderIndex + 2).join(path.sep);
                metadataPath.delete(metadataPath);
                return metadataPath;
              }

              return file;
            })

            console.log(deployMetadata);
            console.log(deleteMetadata);
      # - name: Install Salesforce CLI
      #   if: steps.cache-node-modules.outputs.cache-hit != 'true'
      #   run: |
      #     npm install sfdx-cli
      #     node_modules/sfdx-cli/bin/run --version
      #     node_modules/sfdx-cli/bin/run plugins --core
      # - name: Authenticate test automation org
      #   run: |
      #     echo "${SALESFORCE_JWT_SECRET_KEY}" > server.key
      #     node_modules/sfdx-cli/bin/run force:auth:jwt:grant --clientid ${{ secrets.SF_UTILS_CONSUMER_KEY }} --jwtkeyfile server.key --username ${{ secrets.AUTOMATION_ORG_USERNAME}} --setdefaultdevhubusername -a automation
      #   env:
      #     SALESFORCE_JWT_SECRET_KEY: ${{ secrets.UTILS_JWT_SECRET_KEY }}
